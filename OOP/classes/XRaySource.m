classdef XRaySource < handle
% This class encapsulates the computation of the x ray spectrum and its
% related parameters

% TODO I feel like this class could use some modifications/refactoring to
% improve its internals, its a bit messy currenlty.

    properties
        kVpeak
        exposure
    end % properties
    
    properties (Dependent)
        energies % energies corresponding to elements in spectrum
        spectrum % photon fluence as a function of energy
        mask_values % list of energies included in the mask
    end
    
    properties %(Access = private)
        filter_list % cell array of cell arrays for filters
        spectrum_internal % internal storage for the complete spectrum
        
        mask % mask to select only certain values from the spectrum
        use_default_mask
    end % private properties
    
    properties (Constant)
        % The energies used in the TASMIP code, these are fixed
        tasmip_energies = (1:151)';
    end
        
    methods
        function this = XRaySource(peak_energy, exposure)
            % Constructor for the XRaySource object
            % XRS = XRaySource(peak_energy, exposure)
            this.kVpeak = peak_energy;
            this.exposure = exposure;
            this.filter_list = {};
            % by default mask includes all energies with nonzero counts
            this.use_default_mask = 1;
        end
        
        function addFilter(this, filter_material, filter_thickness)
            % Adds a filter to the x ray source
            % XRS.addFilter(filter_material, filter_thickness)
            
            % create a new filter cell
            new_filter = {filter_material, filter_thickness};
            % add it to the filter list
            this.filter_list = horzcat(this.filter_list, {new_filter});
            % reset the object to regenerate the spectrum
            this.resetSpectrum();
        end
        
        % Removes all filters
        function removeFilters(this)
            this.filter_list = {};
            % reset the object to regenerate the spectrum
            this.resetSpectrum();
        end

        function energies = get.energies(this)
            % Returns the energies with generated photons
            
            % check if we have the energies saved already, if not we need
            % to call generateSpectrum to determine the correct energies
            if isempty(this.spectrum_internal)
                this.generateSpectrum();
            end
            energies = this.tasmip_energies(this.mask);
        end
        
        function spectrum = get.spectrum(this)
            % Returns the non-zero elements of the spectrum generated by
            % the XRaySource
            
            % check if we have the spectrum saved already
            if isempty(this.spectrum_internal)
                this.generateSpectrum();
            end
            spectrum = this.spectrum_internal(this.mask);
        end
        
        function set.kVpeak(this, new_kVp)
            this.kVpeak = new_kVp;
            this.resetSpectrum();
        end

        function set.exposure(this, new_exposure)
            this.exposure = new_exposure;
            this.resetSpectrum();
        end
        
        function values = get.mask_values(this)
            values = XRaySource.tasmip_energies(this.mask);
        end
        
        function set.mask_values(this, values)
            % if an empty vector is passed in, revert to using the default
            % mask
            if isempty(values)
                this.use_default_mask = 1;
                this.mask = (this.spectrum_internal > 0);
                return
            end
            new_mask = false(size(XRaySource.tasmip_energies));
            new_mask(values) = true;
            % turn off the use of the default mask
            this.use_default_mask = 0;
            this.mask = new_mask;
        end
        
        function generateSpectrum(this)
            % Internal function used to do the actual spectrum generation.
            
            % generate base spectrum from tasmip
            spect = tasmip(this.kVpeak, this.exposure);
            % generate the spectrum mask which defaults to nonzero counts
            if this.use_default_mask
                this.mask = (spect > 0);
            end
            % if there are no filters, we are done
            if isempty(this.filter_list)
                this.spectrum_internal = spect;
                return
            end
            
            % Apply the filtration using the Beer-Lambert Law
            for filter = this.filter_list
                % un-cell one level since filter_list is a cell array of
                % cell arrays (each filter is a cell array)
                filter = filter{:}; %#ok<FXSET>
                % get the lmu and thickness values for the filter
                filter_lmu = crosssect(filter{1}, this.tasmip_energies, 'linear');
                filter_thickness = filter{2};
                % apply the filter to the generated spectrum
                spect = spect .* exp( -filter_thickness * filter_lmu );
            end
            % save the generated spectrum
            this.spectrum_internal = spect;
        end
        
        function show(this, masked_bool)
            % Bool set to false will plot the complete internal spectrum
            % instead of the masked spectrum
            figure;
            if nargin == 1
                masked_bool = true;
            end
            % Displays the generated spectrum
            if masked_bool
                spec = zeros(size(this.tasmip_energies));
                spec(this.energies) = this.spectrum;
                plot(this.tasmip_energies, spec);
            else
                plot(this.tasmip_energies, this.spectrum_internal);
            end
            xlabel('Energy (kVp)')
            ylabel('Photon Fluence')
        end
    end % methods
    
    methods (Access = private)
        function resetSpectrum(this)
            % Resets values for the internal spectrum so that the values
            % will be recomputed in response to changes in the state of the
            % object
            this.spectrum_internal = [];
        end
    end
    
    
end % classdef